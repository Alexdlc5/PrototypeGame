Top Down
	if (playerrot.eulerAngles.z < 180 && playerrot.eulerAngles.z > 0 && playerrot.eulerAngles.x < 180 && playerrot.eulerAngles.x > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    //new Vector3(camera offset right, camera off set up, camera offset back)
                    transform.localPosition = new Vector3(2f, avgrot / 15 + 10, -30 - avgrot / 8);
                }
                //only x angle positive 
                else if (playerrot.eulerAngles.x < 180 && playerrot.eulerAngles.x > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, avgrotz / 15 + 10, -30 - avgrotz / 8);
                }
                //only z angle positive
                else if (playerrot.eulerAngles.z < 180 && playerrot.eulerAngles.z > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, avgrotx / 15 + 10, -30 - avgrotx / 8);
                }
                //both angles negative
                else if (playerrot.eulerAngles.z >= 180 && playerrot.eulerAngles.z <= 360 && playerrot.eulerAngles.x >= 180 && playerrot.eulerAngles.x <= 360)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, (360 - avgrot) / 15 + 10, -30 - (360 - avgrot) / 8);
       
                }
                else
                {
                    transform.localPosition = new Vector3(2f, avgrot / 15 + 10, -30 - avgrot / 8);
                }
                transform.localRotation = Quaternion.Euler(10, 0, 1);
Close Follow

 	if (playerrot.eulerAngles.z < 180 && playerrot.eulerAngles.z > 0 && playerrot.eulerAngles.x < 180 && playerrot.eulerAngles.x > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    //new Vector3(camera offset right, camera off set up, camera offset back)
                    transform.localPosition = new Vector3(2f, avgrot / 15 + 2, -7.15f - avgrot / 8);
                }
                //only x angle positive 
                else if (playerrot.eulerAngles.x < 180 && playerrot.eulerAngles.x > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, avgrotz / 15 + 2, -7.15f - avgrotz / 8);
                }
                //only z angle positive
                else if (playerrot.eulerAngles.z < 180 && playerrot.eulerAngles.z > 0)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, avgrotx / 15 + 2, -7.15f - avgrotx / 8);
                }
                //both angles negative
                else if (playerrot.eulerAngles.z >= 180 && playerrot.eulerAngles.z <= 360 && playerrot.eulerAngles.x >= 180 && playerrot.eulerAngles.x <= 360)
                {
                    //changes position and rotation of camera in relation to the player to avoid clipping the ground
                    transform.localPosition = new Vector3(2f, (360 - avgrot) / 15 + 2, -7.15f - (360 - avgrot) / 8);
       
                }
                else
                {
                    transform.localPosition = new Vector3(2f, avgrot / 15 + 2, -7.15f - avgrot / 8);
                }   
                transform.localRotation = Quaternion.Euler(10, 0, 1);